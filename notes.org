PROPERTIES:
:ID:       0d5789bb-e727-4ede-a5cb-afffbc0ff3ed
:END:
#+title: twiki


Twiki == btbd
(Better Than Bash. Definitely.)

[[https://buckrogers.fandom.com/wiki/Twiki][Wiki page about Twiki]]

* TODO
- [ ] describe immutable variable names in grammar
- [ ] describe array and hash querying in grammar
- [ ] allow for mulitple =@= characters before a global.
    no reason to disallow it and it may lead to future functionality akin to ruby's =@foo= instance variables and =@@foo= class variables.

    I'm thinking maybe =@FOO= is scoped to the local namespace and =@@FOO= is truly global.
    NO... that doesn't make sense with nested functions. see
    namespacing---vvv
- [ ] namespacing
  at its core namespacing is a mechanism that says "all this functionality is within this context that i'm calling x". that's a method definition with no args.
- [ ] string interpolation? maybe?

  #+begin_src
    namespace: foo
    -- literally anything
    -- including
    -- namespace: bar
  #+end_src


  - Parsing concern:
    this means we're supporting nested function defs (which we should do to allow for scheme style.

    BUT many languages don't support nested function defs.

    #+begin_src bash
    # bash inner function
    # https://stackoverflow.com/a/31316688/13973
    # note the use of parens instead of curlies
    # this has the side-effect of running the
    # function in a subshell
    f() ( # <--- () NOT {}
        g() {
            echo G
        }
    g
    )

    # Ouputs `G`
    f
    # Command not found.
    g

    #+end_src

    #+RESULTS:

    Being run in a subshell means commands like =cd= and =exit= have different side effects. We can't prevent folks from calling them because there are very good reasons to. Also, the list of restrictions would be eternally incomplete. Folks just need to be warned up front about the side effects of nested functions within their languages.

  - usage concerns:
    how do you call the inner function from outside if it's considered a namespace? usage of inner functions) mean we can't just test "am i in a function" we need a stack of functions (LIFO Last In First Out)
- [ ] define way of specifying 0/1 or more arguments
  - for example =and:= needs at least 2 arguments but could take an unlimited number.

    Something like =def and: [arg arg+]=

    something that took >= 1 args would be
    =def foo: [bar+]=
    zero or more would be
    =def bar: [foo*]=

    Question: Is this just shorthand for
    =def baz: [arg_list]=
    no, because while that works for ~>=1~ args
    it doesn't work for ~>=0~ args.
  - [ ] how does scheme handle this?
- [X] define way of specifying default values for parameters.
  - I think just emulate Racket here. I think racket style would be
  - =def foo: [bar [baz "beedle"]]=
    #+begin_src
    #bdbd
        def foo: [bar [baz "beedle"]]
            concat: bar baz
    #becomes bash
        function foo() {
            local bar="$1"
            local baz="${2:-beedle}"
            concat "$bar" "$baz"
        }
    #+end_src
* Keywords
- def
- def-contract
- true
- false
* Self Documenting

People say languages are "self documenting" but they don't mean it literally.
They could though.

Given a method defined as follows
#+BEGIN_SRC
def concatenate: [bar baz]
    #= [string string] => string
    return bar . baz
#+END_SRC

we could transform that to

#+begin_src
#= Params:
#= bar (string)
#= baz (string)
#=
#= Returns:
#= string
#=
def concatenate: [bar baz]
    #= [string string] => string
    return bar . baz
#+end_src

Rule: any lines beginning with ~\s*#=~ that immediately preceed a method
are assumed to be autogenerated and replaceable. During parsing they are ignored.
Developers can add commentary above them with simple ~\s*#~ lines.

For example

#+begin_src
# concatenates two strings together, optionally inserting
# another string in between.
#
def concatenate: [bar baz ?join_string?]
    #= [string string] => string
    join:    [bar baz]
            (empty? join_string "" join_string)
#+end_src

becomes

#+begin_src
# concatenates two strings together, optionally inserting
# another string in between.
#
#=
#= Params:
#= bar (string)
#= baz (string)
#=
#= Returns:
#= string
#=
def concatenate: [bar baz ?join_string?]
    # [string string] => string
    join:    [bar baz]
            (empty? join_string "" join_string)
#+end_src

** contracts
We're going to copy ruthelessly from [[https://docs.racket-lang.org/guide/contracts.html][Racket Contracts (guide)]] & [[https://docs.racket-lang.org/reference/contracts.html][Racket Contracts (reference)]] here. The underlying language isn't going to support them (unless we target Racket) so we'll have to roll our own. I'm not going to copy the racket implementation because that's too deep of a rabbit hole, and provides way more functionality than i need /right now/.

I'm going to start with "flat contracts" which can be checked immediately. They will be tied to functions only. No declaring variables with contracts (for now).

*** contract syntax
a function with an associated contract is defined with =def-contract= instead of =def=. Its first line must be =contract: ...= which corresponds to Racket's ~(-> ...)~

=contract:= takes a list of lists. Each sub-list starts with one of the named variables of the function and is followed by references to one or more functions which should be applied to the variable. Each referenced function must take one argument and return a boolean.

#+begin_src
def-contract deposit: [amount]
    contract: [[amount number?:~]] => boolean?:~
#+end_src
*** optional argument contracts
Implementation-wise default variables should be addressed /before/ the contract is tested. So if we have a =[foo "bar"]= argument for which nothing has been passed in the implementation does something like the following, which ultimately means, we don't have to deal with this problem.

#+begin_src
def-contract defaulted: [[foo "bar"]]
	contract: [[foo string?:~]]
  #...
# becomes this in Janet
(defn defaulted
    "descriptor"
    [&opt foo]
    (default foo "bar")
    (contract (list (list foo string?)))
    #...
)
#+end_src

the contract function itself iterates over each sublist
#+begin_src
def test-contract: [var function_ref]
    if ~:function_ref var
        true
        error: "#{var} did not satisfy the contract #{function_ref}"

def contract: [vars_and_tests]
    # vars_and_tests = [ [foo string?:~] [bar number?:~ positive?:~]]
    each: sub_list vars_and_tests
          let: [the_var first: sub_list]
               [tests rest: sub_list]
               each: test tests
                   test-contract: the_var test

        
#+end_src
*** variadic argument contracts
???
*** contract specific standard library
(ugh another batch of things to write)
Note that these are standard functions that can be used whenever needed.
**** TODO
- [ ] =any?:= - literally anything
- [ ] =any-one?:= - literally any /one/ thing
- [ ] =integer?:=
- [ ]
** function signature annotations


In form, function signature annotations reflect the function they are annotating.
There is a list containing a data type for each argument the function takes followed by a rocket (~=>~) and then the response type.

- annotating arguments with default parameters
  In the function signature these would besomething like  =def stuff: [foo [bar "baz"]]= where the second parameter has a default of ="baz"= if you don't pass it in. These arguments should always be of the same type as their deafult. As such they are annotated as that type.

    #+begin_src
    def stuff [foo [bar "baz"]]
        # [integer string] => string
		...
    #+end_src
- annotating arguments that take multiple types
    Sometimes an argument is expected to be one of multiple types or literally anything. If an argument can take any type of input, its type is annotated as =any=. If an argument can take one of a specific set of types you surround it with angle brackets and separate the different types with a pipe (=|=)

    #+begin_src
    def variable_stuff: [foo bar]
    	# [<string | integer> any] => string
    	...
    #+end_src
- annotating returned tuples
    If you function doesn't just return a list, but returns a very specific list with a predefined form you can specifically note that in the annotations.

    #+begin_src
    def tuple_maker: [a_number]
    	# [integer] => [string integer <boolean | integer>]
    	...
    #+end_src
- annotating tuple arguments
  This is not currently supported. In this case just specify =list= as the argument type.

- annotating variadic arguments
    These follow a similar pattern to variadic arguments in the method signature. You annotate them as you would any other argument, except that you follow it with an asterisk or plus that matches the argument in the signature. In the case of variable types, the asterisk or plus goes after the angle brackets

    #+begin_src
    def variadic: [foo bar*]
    	# [string <string|integer>*] => string
    	...

    def other_variadic: [name numbers_to_add*]
    	# [string integer*] => string
    	...
    #+end_src

*** data types
This is the list of data types that can be in your annotations. As noted above when returning a tuple you're encouraged to define that in the return type instead of just saying =list=. Note that types are case sensitive.

- any
- boolean
- dictionary
- float
- function
- integer
- list
- string


** auto-testing
This builds on [[Self Documenting][Self Documenting]]

If we've got ~[integer, string] => string~
we can do basic fuzzing.
However, without more details there are some cases where this will fail.
For example if the function takes a string, but requires it to be only two characters. That's going to blow up if the fuzzer passes it "foobarbaz".
So, we need a mechanism to disable fuzzing on a per-function basis.

#+begin_src
# takes a string and repeates it a number of times
# Ex. string_multiplier: [3 "ho"] => "hohoho"
def string_multilpier: [times string]
	# [integer, string] => string
#+end_src

* Variables
- snake case: =file_path=
  - must end with a letter or number
  - must start with a letter
- globals: =@ALL_CAPS_SNAKE_CASE=
  - preceeded by =@= (kinda looks like a globe)
  - all caps
  - snake case
- variables must be declared before they can be used.
- currently /not/ supporting =null= variables.
- declaration
    =var: <variable_name> <atom>=

    For example.
    =var: foo_bar "baz"=
    or
    =var: @FOO_BAR "baz"=
- you can't re-declare a variable that is in scope
- you can't use a variable that hasn't been declared.
- mutability
  - variables of any type are mutable by default
  - to define an immutable variable preface it with a "bang" (exclamation point) =!=
    This may feel a little weird to folks in languages where =!= is used for negation. Here we use the =not:= function for negation.
    #+begin_src
    foo # mutable
    !bar # immutable
    #+end_src

* Working With Arrays And Hashes
=foo[x]= and =foo{y}=
* Scope
- a variable declared within a function is only referencable within that function.
- a variable declared within a namespace is only referencable within that namespace
* Assignment
handled via the ~=:~ function
E.g. ~=: foo "bar"~ would set the ~foo~ variable to hold the ~"bar"~ value.

* Arithmetic
handled via the following functions
#+BEGIN_EXAMPLE
ASSIGNMENT =:
NOT_EQUALS !=:
EQUALS ==:
GREATER_OR_EQUAL >=:
GREATER_THAN >:
LESSER_OR_EQUAL <=:
LESSER <:
#+END_EXAMPLE

* Functions
** Defining them
*** naming conventions
- must end with a =:=
- Kebab Case: =cool-calc=, =is-cool?=, =replace!=
- ends with letter, =!=, or =?=
  - =!= implies mutation
  - =?= implies it'll return a boolean
*** named functions
- a named function is defined with =def <function_name>: [<argument list>]=
- anything indented below it is part of it
*** an anonymous function
These are currentyly unimplemented but i'm thinking they start like this
- an anonymous function is defined with =->: [argument list]=
- anything indented below it is part of it
*** function references
- a pointer to a function. For example if a function takes a function as an argument. You only use this syntax at the calling site.
- a function name followed by a tilde =foo:~=
- dereferencing in a variable is done by flipping the referenced function sign and sticking it on the other end.

  For example =my-function: [foo]= is referenced as =my-function:~= which ends up in a variable somewhere like =some_function= which we then invoke with =~:some_function=

#+begin_src
# a function that takes a function as its first argument
def foo: [some_func bar]
    # [function string] => string
    ~:some_func bar

# calling that function and passing it a pointer to some other function
foo: a-function:~ "baz"
#+end_src
*** return values
A function /must always/ return something or raise an error. If your function only generates side-effects (like printing to the screen) then return a boolean indicating if it completed successfully.

*** TODO
- [ ] raise syntax error if def line not followed by indented line
** Calling them
** Standard Library
Functions whose implementation are hardcoded in the parser for the target language.
see =standard_lib/language= (e.g. =standard_lib/bash.sh=)

- [ ] string-join:

    joins strings with "join-with"

    #+begin_src
    def string-join-with: [join_with strings+]
    	if eq: target-lang "bash"
    		raw: "
        join_string="$1"
        shift
        arr=("$@")
        result=""
        for index in "${!arr[@]}";
        #for i in "${arr[@]}";
        do
            if [ $index -gt 0 ]; then
                result+="$join_string"
            fi
            result+="${arr[$index]}"
        done
        echo $result

    " # end raw

    def string-join: [strings+]
    	string-join-with: "" strings
    #+end_src
]

- [ ] type
  - generates a string representation of an object's type
  - String, Integer, Float, List, Function
- [ ] inspect
  - generates a string representation of any object
  - <String "fooberries">
  - <Integer 4>, <Float 6.4>
  - <List [3, "bar"]>
  - <Function "def foo [bar baz]">
    - that might be hard
    - implies that whenever we define a function
      we store its signature
- [ ] if
- [ ] cond
- [ ] when
- [ ] while
- [ ] map (takes a function) & returns a list
  - =def map: [function_ref list]=
- [ ] append (appends to list)
- [ ] each (takes a function)
- [ ] +
- [ ] -
- [ ] /
- [ ] *
- [ ] ask
  - "ask" the user for input
- [ ] println
- [ ] print
- [ ] =and:=
  - =def and: [atoms+]=
  - tests if /all/ of the items are true
- [ ] =or:=
  - =def or: [atoms+]=
  - test if /any/ of the items are true
- [ ] =not:=
  - =def not: [atoms+]=
  - negates the results of =and:=
- [ ] =shell:=
  - =def shell: [args_list]=
  - takes an array of strings (literally the elements that will be passed to the shell like =["ls" "-la"]=)
  - returns a tuple of
    - STDERR
    - STDOUT
    - exit code
    #+begin_src bash
    # t_std & t_error are arrays of lines with their trailing newline stripped off
    # t_ret is an integer containing the exit codde of the command
    unset t_std t_err t_ret
    eval "$( (echo std; echo err >&2; exit 2 ) \
            2> >(t_err=$(cat); typeset -p t_err) \
            > >(t_std=$(cat); typeset -p t_std); t_ret=$?; typeset -p t_ret )"

    #+end_src
- [ ] =to-int:=
  - =def to-int: [x]=
  - takes anything and converts it to an int or goes boom.
- [ ] =to-string:=
  - =def to-string: [x]=
  - takes anything and converts it to a string
- [ ] =method-call:=
  - =def method-call: [var_obj arg_list]=
  - assumes you've got an object from a target language stored in a variable
  - calls the given method, with the given args on that object
  - I feel like it should be an error to have a =method_call:=
    without also having some sort of declaration of target lang.
- [ ] =target-lang:=
  - required invocation if =method_call:= is used (compilation error if not).
  - warning if =method_call:= is /not/ used.
- [ ] dictionary methods
  - =dict-get: dict key=
  - =dict-set: dict key val=
  - =dict-keys: dict=
  - =dict-values: dict=

* Whitespace Sensitivity
** parsing rule
the line at =current_indentation_level - 1= must be
- a function call =foo: x= or =bar:=
- a function definition =def foo: [x]=
** function calls
first line is the function and optionally it's first argument
=foo: arg1=
anything indented is expected to be an argument
#+begin_src
foo: arg1
    arg2
#+end_src
further indentation is expected to be an argument to the thing before it
which again, must be a function call
#+begin_src
foo: arg1
    arg2: #<-- a function call
        arg3
#+end_src

* Parentheses [UNIMPLEMENTED]
Explicitly a grouping tool.

* Numbers
- [X] positive integers
- [X] negative integers
- [ ] positive floats (e.g. =1.234=)
- [ ] negative floats (e.g. =1.234=)
- [ ] reals (e.g. =3/4=)
* Comments
- [X] anything after a ~#~ is a comment
- [X] a line beginning with ~\s*##~ is the start of a multi-line comment
      anything indented under that line is a comment
      comment ends on the next line matching =^\t*##$=
- [ ] a line starting with ~\s*#=~ is assumed to be auto-generated
  (see Self Documenting) and replaceable
- [ ] ~\s*#=~ indented and immediately after a =def= line defines the types of the params
- [ ] need unit tests for multiline comments

  #+begin_src
##
    commentary
    about baz function
##
#=
#= Params: none
#=
#= Returns: string
def baz: []
    #= [] => string
    "baz"
  #+end_src
* Scope [UNIMPLEMENTED]
there are 2 scopes:
- global
- function
  - def foo blocks
  - lambdas

** Scope Enforcement
when in a method you should only be able to reference a variable that is defined in that method, either internally or as an argument, or in the global space.
* contracts
I'm thinking a pseudo-contract system that builds on the [[Self Documenting][Self Documenting]] functionality. Initialially at least, it would just trust that you've kept those comments up to date. and make sure that the output of one thing lines up with the input of what it's being passed to. This is very simplistic, and limited but it'd address a number of common human errors

#+begin_src
def foo: [bar]
	#= [string] => string
	"foo"
def bar: [fum]
	#= [string] => string
	concat: fum "bar"
def add: [x y]
	#= [int int] => int
	+: x y
bar: foo: # valid. returns "foobar"
bar: add: 1 2 # error. "bar: takes a string but add returns an int"
#+end_src
* types
If we're going to have a self documenting language then we have to have a concept of object types. So, what types of objects does this language support

- integers
- floats
- strings
- boolean
- list
- dictionary
  - ~var: my_dict {foo => bar "baz" => 3 2.6 => foo: }~
  - note: you can't use lists or dictionaries for keys in a dictionary
  - for now we're going to use the annoying lispy ways of accessing them
- function_ref
  =foo:~= is a reference to the =foo:= function. You would use this when passing around a named function to be called later.
- function
